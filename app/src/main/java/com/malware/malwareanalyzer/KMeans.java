package com.malware.malwareanalyzer;

import java.util.ArrayList;
import java.util.Scanner;
import java.io.*;
/**
 * Created by siqi zhang on 5/21/2016.
 */
public class KMeans
{
    //Number of Clusters. This metric should be related to the number of points
    private int NUM_CLUSTERS = 0;
    //container
    public ArrayList<Point> points;
    public ArrayList<Cluster> clusters;

    public KMeans(ArrayList<Point> observations, ArrayList<Point> centroids)
    {
        this.points = observations;
        NUM_CLUSTERS = centroids.size();
        this.clusters = new ArrayList<Cluster>();
        for(int i =0; i < NUM_CLUSTERS; i++)
        {
            Cluster one = new Cluster(i);
            one.setCentroid(centroids.get(i));
            this.clusters.add(one);
        }
    }

    //The process to calculate the K Means, with iterating method.
    public int calculate(int n_points)
    {
        int iteration = 0;
        boolean finish = false;
        // Add in new data, one at a time, recalculating centroids with each new one.
        while(!finish)
        {
            //Clear cluster state
            clearClusters();

            ArrayList<Cluster> lastCentroids = new ArrayList<Cluster>();
            //copy every element
            for(int i = 0; i < this.clusters.size(); i++)
            {
                Cluster temp = new Cluster(this.clusters.get(i));
                lastCentroids.add(temp);
            }
            //Assign points to the closer cluster
            assignCluster(n_points);
            //Calculate new centroids.
            calculateCentroids();

            ArrayList<Cluster> currentCentroids = new ArrayList<Cluster>(this.clusters);
            iteration++;
            //Calculates total distance between new and old Centroids
            double distance = 0;
            for(int i = 0; i < lastCentroids.size(); i++)
            {
                distance += Point.distance(lastCentroids.get(i).centroid,currentCentroids.get(i).centroid);
            }
            //if no centroids changed
            if(distance == 0)
            {
                finish = true;
            }
        }
        return iteration;
    }

    //clear all points in clusters
    private void clearClusters()
    {
        for(int i = 0 ; i < NUM_CLUSTERS; i++)
        {
            clusters.get(i).clear();
        }
    }

    private void assignCluster(int n_points)
    {
        double max = Double.MAX_VALUE;
        double min = max;
        int cluster = 0;
        double distance = 0.0;

        for(int i = 0; i< n_points;i++)
        {
            min = max;
            for(int j = 0; j<NUM_CLUSTERS; j++)
            {
                Cluster c = clusters.get(j);
                distance = Point.distance(points.get(i), c.getCentroid());
                if(distance < min)
                {
                    min = distance;
                    cluster = j;
                }
            }
            points.get(i).setCluster(cluster);
            clusters.get(cluster).addPoint(points.get(i));
        }
    }
    //recompute the centroid based on the observations the cluster has
    private void calculateCentroids()
    {
        for(int i = 0; i< NUM_CLUSTERS; i++) {
            ArrayList<Point> list = clusters.get(i).points;
            int n_points = list.size();
            //only recompute the centroid when the cluster is not empty i.e. it has > 0 points
            if (n_points > 0)
            {
                ArrayList<Double> sum = new ArrayList<Double>();
                int dimension = list.get(0).dimension;
                //accumulate the data at each dimension
                for (int j = 0; j < dimension; j++) {
                    double data = 0;
                    for (int k = 0; k < n_points; k++) {
                        data += list.get(k).data.get(j);
                    }
                    data = data / n_points;
                    sum.add(data);
                }
                Point centroid = new Point(sum);
                clusters.get(i).centroid = centroid;
            }
        }
    }
}