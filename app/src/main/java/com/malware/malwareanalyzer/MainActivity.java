package com.malware.malwareanalyzer;
 import android.app.ProgressDialog;
 import android.content.Intent;
 import android.os.AsyncTask;
 import android.support.v7.app.AppCompatActivity;
 import android.os.Bundle;
 import android.util.Log;
 import android.view.View;

 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.ArrayList;

public class MainActivity extends AppCompatActivity {

    //Number of innocent data
    public static int NUM_INNO_POINTS = 0;
    //Number of malicious data
    public static int NUM_MALI_POINTS = 0;
    //dimension
    public static int DIMENSION = 135;

    public static NaiveBayes prediction;

    boolean flag = true;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        if(flag)
            new training().execute();
    }

    public void analyzeClick(View view) {

        Intent i = new Intent(this, AppList.class);
        startActivity(i);
    }

    public void aboutUS(View view){
        Intent i2 = new Intent(this, contactUs.class);
        startActivity(i2);
    }

    public void train(){
        BufferedReader reader = null;

        try {
            reader = new BufferedReader(new InputStreamReader(getAssets().open("malware.txt"),"UTF-8"));
            String line;
            while ((line = reader.readLine()) != null) {
                if(line.length() > 0) {
                    StringBuilder text = new StringBuilder();
                    text.append(line);
                    Log.d("Test:", "" + text);
                    text.append('\n');
                }
            }
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        finally{
            if(reader != null){
                try {
                    reader.close();
                } catch (IOException e) {

                }
            }
        }
        //add in the machine learning part::
        //--------------------------------------------------------------------------------------------------------------
        //read the innocent permission file
        ArrayList<Point> innocent = new  ArrayList<Point>();
        try
        {
            reader = new BufferedReader(
                    new InputStreamReader(getAssets().open("Innocentapp.txt")));
            // do reading, usually loop until end of file reading
            String mLine;
            //build observations
            while ((mLine = reader.readLine()) != null)
            {
                //read one line of permission
                ArrayList<Double> oneLine = new ArrayList<Double>();
                for(int a = 0; a < mLine.length(); a++)
                {
                    oneLine.add((double)Character.getNumericValue(mLine.charAt(a)));
                }
                Point oneData = new Point(oneLine);
                //add point to observations
                innocent.add(oneData);
                NUM_INNO_POINTS++;
            }
        }

        catch (IOException e)
        {
            e.printStackTrace();
        }

        //warning: hard code remove the first element in the first element of the observation

        // -----commented out 2 lines below------------

        innocent.get(0).data.remove(0);
        innocent.get(0).dimension -=1;

        //build centroid
        ArrayList<Point> centroid = new ArrayList<Point>();


        for(int a =0; a <DIMENSION; a++) // changed DIMENSION to har coded 10 clusters
        {
            ArrayList<Double> centroid_location = new ArrayList<Double>(DIMENSION);
            //initialize
            for(int x = 0; x < DIMENSION; x++)
            {
                centroid_location.add((double)0);
            }
            centroid_location.set(a, (double)1);
            Point pt = new Point(centroid_location);
            centroid.add(pt);
        }
        KMeans innocent_kmeans = new KMeans(innocent, centroid);
        System.out.println(innocent_kmeans.calculate(NUM_INNO_POINTS));
        //--------------------------------------------------------------------------------------------------------------
        //read the malicious permission file
        ArrayList<Point> malicious = new  ArrayList<Point>();
        try
        {
            reader = new BufferedReader(
                    new InputStreamReader(getAssets().open("malware.txt")));
            // do reading, usually loop until end of file reading
            String mLine;
            //build observations
            while ((mLine = reader.readLine()) != null)
            {
                //read one line of permission
                ArrayList<Double> oneLine = new ArrayList<Double>();
                for(int a = 0; a < mLine.length(); a++)
                {
                    oneLine.add((double)Character.getNumericValue(mLine.charAt(a)));
                }
                Point oneData = new Point(oneLine);
                //add point to observations
                malicious.add(oneData);
                NUM_MALI_POINTS++;
            }
        } catch (IOException e)
        {
            e.printStackTrace();
        }

        //warning: hard code remove the first element in the first element of the observation
        KMeans malicious_kmeans = new KMeans(malicious, centroid);

        System.out.println(malicious_kmeans.calculate(NUM_MALI_POINTS));
        //--------------------------------------------------------------------------------------------------------------
        //Make prediction
        prediction = new NaiveBayes(innocent_kmeans.clusters, malicious_kmeans.clusters, NUM_INNO_POINTS, NUM_MALI_POINTS);
        flag = false;
    }


    private class training extends AsyncTask<Void,Void,Void> {

        private ProgressDialog progressDialog;

        @Override
        protected Void doInBackground(Void... params) {
            train();
            return null;
        }

        @Override
        protected void onPreExecute() {
            progressDialog = ProgressDialog.show(MainActivity.this,null,"Initializing");
            super.onPreExecute();
        }

        @Override
        protected void onPostExecute(Void aVoid) {
            progressDialog.dismiss();
            super.onPostExecute(aVoid);
        }
    }
}